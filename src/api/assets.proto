syntax = "proto3";
package genesys;

import "api/intervals.proto";
// import "api/asset_groups.proto";
import "api/service_catalogue.proto";


message Asset {
    int32 id = 1;
    string name = 2;
    int32  connection_point_id = 5;   // a physical type asset-group
    Battery battery = 9 ;
}

message AssetEnergy {
// do we need this ? differentiate based on tech here?
// e.g. BatteryEnegry, ..
}

message AssetOutput {
// again should we place the outputs under assets and then differentiate based on tech?
}

message Battery {
    BatteryEnergy energy_property = 5;
    BatteryPower power_property = 6;
    // BatteryInterval battery_interval = 9;
    BatteryDegradation degradation_property = 11;
    repeated BatteryService services = 12;
    repeated BatteryExpense expenses = 13;
}

message BatteryEnergy {
    message BatteryEnergyNominalLimit{
        BasicQuantity capacity = 1; // single value will be used
        BasicQuantity depth_of_discharge_max = 2;
        BasicQuantity depth_of_discharge_min = 3;
    }

    message BatteryEnergyOperationLimit{
        IntervalQuantityGroup capacity = 1; // single value will be used
        IntervalQuantityGroup depth_of_discharge_max = 2;
        IntervalQuantityGroup depth_of_discharge_min = 3;
    }
    
    message BatteryEnergyLoss{
        BasicQuantity charge_efficiency =  1;
        BasicQuantity discharge_efficiency = 2;
        // BasicQuantity cell_charge_efficiency =  5;
        // BasicQuantity cell_discharge_efficiency = 6;
        // BasicQuantity inverter_efficiency =  9;
    }

    BatteryEnergyLoss energy_loss  = 3;
    BatteryEnergyOperationLimit operation_limit = 4;
    BatteryEnergyNominalLimit nominal_limit = 5;

    BasicQuantity initial_energy =7;
    BasicQuantity terminal_energy =8;

    BasicQuantity initial_energy_avrg_cost = 11;
    BasicQuantity terminal_energy_avrg_cost = 12;

}

message BatteryPower {
    message BatteryPowerOperationLimit{
        IntervalQuantityGroup charge_max = 2;
        IntervalQuantityGroup discharge_max = 3;
    }

    message BatteryPowerNominalLimit{
        BasicQuantity charge_max = 2;
        BasicQuantity discharge_max = 3;
    }

    message BatteryRamp {
        BasicQuantity ramp_up_max = 1;
        BasicQuantity ramp_down_max = 3;
    }
    
    BatteryPowerOperationLimit operation_limit = 2;
    BatteryPowerNominalLimit nominal_limit = 3;
    BatteryRamp power_ramp_limit = 5;
}

message BatteryDegradation {
    BasicQuantity reduced_capacity = 2;
    BasicQuantity cycling_cost = 4;
    BasicQuantity cycling_limit = 5;
}

message BatteryInterval {
    int32 id = 1;
    string name = 2;
}

message BatteryExpense {
    int32 id = 1;
    string name = 2;

}

message BatteryService {
    //  can we have a service/product that is a combination of these basic services? 
    // like peak shaving, is a bit of backup and a bit of regulation
    //  even regulation is not something of continous, so would we populate both of these for a product,
    //  or have these types overlap features like call_chance, required_energy?
    int32 id = 1;
    string name = 2;
    BatteryServiceArbitrage arbitrage = 4;
    // BatteryServiceBackupPower  backup_power = 5;
    // BatteryServiceSetpointFollow setpoint_following = 6;
}

message BatteryServiceArbitrage {
    int32 id = 1;
    string name = 2;
    repeated int32 resource_economic_ids = 5;
    bool cross_market_convergence_arbitrage = 7; // default would be false
    repeated EconomicsPrice prices = 10;  
    // these prices probably won't be provided by the user, but could be received from the energy-sources
    //  which are defined in the AssetGroup and would be provided by it, or maybe even generated by it.
    //  but we could have a case where we want to directly put it in the asset.
    //  will see if I would keep this in the intf.
}

message EconomicsPrice{
    //  Economics; Prices; Costs; Revenues; 
    int32 id = 1;
    string name = 2;
    int32 market_product_price_id = 5;
    int32 utility_tariff_price_id = 7;
    MarketProductPrice market_product_price = 10; // this is to dirrectly define a product price
    TariffPrice utility_tariff_price = 11;
    LocalCustomPrice   custom_local_price = 12;
}

message LocalCustomPrice {
    //  resource price; internal price; combination price; 
    int32 id = 1;
    string name = 2;
    IntervalQuantityGroup price = 5;

    // resource_price_energy
    // resource_price_capacity
    // resource_price_custom
}